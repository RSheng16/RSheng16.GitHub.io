---
layout: post
title: "x86_assembl"
description: "The brain is a good thing, but unfortunately I need to record"
tag: error
---

## x86的寻址方式
段地址 * 16 + 偏移地址

## x86实模式下的内存布局
![](/images/x86_assembly/Memory_layout_real_mode.jpg)

## 字符显示模式
两个字节显示一个字符
 - 第一个字节表示字符
 - 第二个字节表示样式
```
mov byte [0], 'T'
mov byte [1], 11110000b

;显示He
mov byte [0], 'H'
mov byte [2], 'e'
```
## 7c00问题
IBM PC 5150 内存布局
![](/images/x86_assembly/IBM_5150.jpg)

## 寄存器
| 寄存器 | 描述             |
| ----- | ---             |
| AX    | 累加结果数据      |
| BX    | 数据段数据指针    |
| CX    | 字符串和循环计数器 |
| DX    | I/O 指针         |
| DI    | 目的操作数指针     |
| SI    | 源操作数指针      |
| SP    | 栈指针           |
| BP    | 栈数据指针        |

| 寄存器 | 高八位 | 低八位 |
| ----- | ----- | ------|
| AX    | AH    | AL    |
| BX    | BH    | BL    |
| CX    | CH    | CL    |
| DX    | DH    | DL    |

| 段寄存器 | 描述         |
| ------- | ----------- |
| CS      | 代码段寄存器  |
| DS      | 数据段寄存器  |
| SS      | 栈段寄存器   |
| ES      | 额外的寄存器  |

 - IP
 - FLAG / psw
```
mov cx, (message_end - message)

loop1:
	mov al, [ds:si]
	mov [es:di], al

	inc si
	add di, 2

	loop loop1

message:
	db "hello world!!!", 0
message_end:
```
## 数据类型
```
db 100; define byte
dw 0xaa55; define word
dd 0x12345678; define double word

dw 55aah
db 1111_0000b
db 0b0000_1111

db "hello world!!!", 0, 12, 123
```
![](/images/x86_assembly/type.jpg)

## 8086寻址方式
 - 立即数的位数
 - 默认段寄存器
 - 乘法指结果在两个寄存器

## 标志寄存器
| 位 | 标志 | 英文 | 描述 |
| -- | --- | --- | --- |
| 0  | CF  | Cerry | 进位标志 |

## 转移指令
8086程序的指令地址 cs:ip 下一条指令的地址，物理地址 = cs << 4 + 16

jmp short start 占用两个字节，jmp 偏移地址 -128 - 0x127
jmp neaar start 占用三个地址，-32768 - 32767
改变偏移地址 只能寻64KB内存空间

<!-- jmp far -->
改变段地址
jmp far cs:ip

cmp ax, bx ; sub ax, bx ——> flag

## 补码
负数的补码是原码取反再加一
x + 1 = 0 ——>  x = -1

0b1111_1111 = -1
0b1111_1110 = -2

0b1111_1011 = -5

## 堆栈和函数
call faction ——> push ip
                 jmp faction
ret ——> pop ip
?? 代返回值的函数?

### 远调用
call far faction ——> push cs
                     push ip
                     jmp faction
retf ——> pop ip
         pop cs
```
call 0:print; calf

halt:
  jmp halt

print:
  push ax
  push bx
  push es

  mov ax, 0xb800
  mov es, ax
  mov bx, [video]
  mov byte [es:bx], '.'
  add word [vide0], 2

  pop es
  pop bx
  pop ax

  retf

voido:
  dw 0x0
```

## 内中断和异常
 - 远调用
 ```
 call far [faction]

 faction:
  dw print, 0; ip, cs
 ```
 - 内存布局
 0x000 - 0x3ff ——> 0x400B
 一个中断占4B
 0x400 / 4 = 0x100 ——> 256个

 0 除法异常  0 - 3
 0x80 linux系统调用，软中断 内存位置：(0x80 * 4 — 0x80 * 4 + 3)
 - 内中断（软中断）
 ```
 ;注册中断处理函数
 mov word [0x80 * 4], faction
 mov word [0x80 * 4 + 2], 0

 ;触发中断
 int 0x80; push ip; push cs; push flag

 halt:
   jmp halt

 print:
   push ax
   push bx
   push es

   mov ax, 0xb800
   mov es, ax
   mov bx, [video]
   mov byte [es:bx], '.'
   add word [vide0], 2

   pop es
   pop bx
   pop ax

   iret; pop flag; pop cs; pop ip
 ```
 - 异常
 异常与内中断的主要区别是触发机制的不同
 ```
 ;注册中断处理函数
 mov word [0x0 * 4], faction
 mov word [0x0 * 4 + 2], 0

 ;触发中断
 mov dx, 0
 mov ax, 1
 mov bx, 0
 div bx ;dx:ax / bx
 ```
